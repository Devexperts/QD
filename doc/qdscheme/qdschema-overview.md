# Первая версия машинно-читаемой схемы для QD.
## Формат.
В качестве формата выбран XML, для которого написана XSD-схема,
позволяющая максимально валидировать правильность схем стандартными средствами.

К сожалению, полную валидацию на основе XSD не представляется возможным сделать
по нескольким причинам: во-первых, в схеме будут элементы без глобально-уникальных
идентификаторов и «прошить» всё проверками ссылок не получается и, во вторых,
полная QD схема, подлежащая проверка, собирается из нескольких файлов.

## Загрузка схемы — файлы и ссылки.
QD-схема собирается из одного или нескольких файлов, каждый из которых должен
быть правильным (valid) XML-файлом и проходить проверку с помощью XSD-схемы
независимо от других файлов.

Файлы грузятся один за другим, и каждый следующий файл имеет больший приоритет,
чем все предыдущие. В случае ошибки загрузки или проверки любого файла загрузка
всей схемы прекращается с ошибкой.

После загрузки каждого следующего файла происходит его объединение с
уже загруженными файлами. Объединение происходит на семантическом, а
не синтаксическом уровне. Объекты с одинаковыми именами, встречающиеся в
нескольких файлах, обновляются данными из только что загруженного файла.
Любые разрешимые конфликты разрешаются в пользу данных загруженных из
нового файла.

Любой файл может содержать инструкции импорта других файлов в своём начале,
в качестве первых инструкций. Такие импортированные файлы считаются загружаемыми
перед включающим их файлом, в порядке инструкций о включении.

Для предотвращения случайных переопределений объектов требуется, чтобы все
обновления были помечены как обновления, а не новые объекты. Это позволяет избежать
ситуации когда пользовательское добавление к стандартной схеме становится изменением
новой версии стандартной схемы, в которую мы добавили объекты с такими же именами
как (неизвестные нам) пользовательские.

Разрешение всех ссылок между объектами (например, приписывание типов полям записей)
и проверка их целостности происходит только после слияния всех файлов. Поэтому
более поздние файлы могут изменить смысл типов, использованных в файлах,
загруженных ранее.

## Обзор типов объектов, описываемых схемой.
QD-Схема может описывать следующие объекты, сгруппированные в соответствующие
контейнеры:

1. `type` — пользовательские типы данных и их именованные копии. Позволяет для
   каких-то типов сделать пользовательский набор методов доступа, а так же
   позволяет переключать представление типа `decimal` для всей схемы сразу
   или отдельных полей.

1. `enum` — описание типов-перечислений, которые могут быть использованы
   для расшифровки полей-флагов.

1. `record` — записи QD, используемые в транспортных форматах.

1. `generator` — определение семейства одинаковых записей QD, отличающихся только
   именами. Генераторы помещаются в тот же контейнер, что и объекты типа
   `record`, но имеют отдельное от них пространство имён.

1. `enable` и `disable` — правила включения и отключения отдельных полей записей в данном
   экземпляре схемы.

### Именованные объекты и их общие атрибуты.
Почти все объекты схемы являются именованными, что позволяет переопределять
и изменять их загружая несколько файлов. Каждый следующий файл
может переопределять или изменять уже существующие именованные объекты.

На данный момент только правила `visibility` не являются именованными.

Все именованные объекты имеют обязательные атрибут `name` и
опциональный `mode`.

Атрибут `name` задаёт имя объекта, и все объекты одного типа должны быть
уникальны в рамках одного файла. Именно это имя используется для
сопоставления объектов при объединении нескольких файлов.

Атрибут `mode` может принимать значения `new` (по умолчанию) или `update`.
Этот атрибут определяет, является описываемый объект новым (`new`) или
должен при слиянии файлов обновить существующий объект с таким же типом и
именем.

Если при объединении файлов объект с атрибутом `mode` со значением `new`
пытается обновить существующий объект, то загрузка схемы завершается
с ошибкой.

Для каждого объекта с атрибутом `mode` со значением `update` должен найтись
переопределяемый объект (из предыдущих по очереди загрузки файлов),
иначе загрузка схемы завершается с ошибкой.

### Обработка правил `visibility`.
Правила включения-отключения полей записей и самих записей не имеют имён и не
переопределяются.

Все правила выполняются в момент конфигурирования ядра QD в том порядке,
в котором они были загружены. Последнее сработавшее правило и определяет
состояния поля или записи — разрешено или запрещено.

### Документация.
Почти все объекты в схеме (не только объекты верхнего уровня, такие как
типы и записи, но и поля записей или значения перечислений) могут
содержать вложенный элемент документации `<doc>`. Содержание этого
элемента — произвольный текст, необходимый для документирования содержащего
его объекта. Этот элемент, если он присутствует, должен быть первым
элементом в своё родительском элементе и может присутствовать максимум
один раз.

## Общая структура одного файла схемы.
На данный момент поддерживается только один формат файла схемы: XML.

Каждый файл схемы должен быть полностью валидным XML-документом, отвечающим
стандарту [Extensible Markup Language (XML) 1.1 (Second Edition)](https://www.w3.org/TR/xml11/)
и содержащемся в пространстве имён `https://www.dxfeed.com/datascheme`.

Файл так же может ссылаться на [XML-схему версии 1.0](https://www.w3.org/TR/xmlschema-1/) `dxfeed-schema.xsd` или
[версии 1.1](https://www.w3.org/TR/xmlschema11-1/) `dxfeed-schema-1.1.xsd`. Даже в отсутствии такой ссылки
файлы будут проверены на соответствие этой схеме.

Корневым элементом (элементом документа) файла схемы является элемент `<dxfeed>`.

В документе может содержаться несколько инструкций импорта других файлов,
а так же контейнеры для типов, перечислений, записей и правил видимости.

Инструкции импорта должны идти первыми, а контейнеры должны следовать после них 
в описанном порядке. Каждый контейнер может встречаться один
раз или отсутствовать.

### Инструкции импорта.
Инструкции импорта записываются как элемент `<import>` без атрибутов.
Этот элемент должен содержать только простой текст и этот текст
интерпретируется как URL, относительный URL родительского документа.

В случае невозможности проинтерпретировать этот URL или загрузить
файл по данному адресу загрузка схемы завершается с ошибкой.

### Контейнер типов.
Контейнером типов служит элемент `<types>` который не имеет атрибутов
и содержит в себе произвольное число элементов `<type>`.

### Контейнер перечислений.
Контейнером перечислений служит элемент `<enums>` который не имеет атрибутов
и содержит в себе произвольное число элементов `<enum>`.

### Контейнер записей и генераторов записей.
Контейнером записей служит элемент `<records>` который не имеет атрибутов
и содержит в себе произвольный набор элементов `<record>` и `<generator>`.

### Контейнер правил видимости.
Контейнером записей служит элемент `<visibility>` который не имеет атрибутов
и содержит в себе произвольное число элементов `<enable>` и `<disable>`
в произвольном порядке. Порядок правил видимости важен.

## Типы объектов подробно.
### Типы.
Элемент `<type>` описывает псевдоним для одного из встроенных типов.
Это позволяет задавать формально независимые типы для различных полей
и переключать их, переопределяя типы позже.

Элементы `<type>` помещаются в контейнер `<types>`.

Тип является именованным объектом и может содержать документацию.

Помимо `name` у типа есть второй обязательный атрибут: `base`. Этот атрибут
должен содержать имя другого типа, встроенного или так же определённого.

После загрузки и объединения всех файлов схемы для каждого типа выясняется,
в какой встроенный тип он превращается. Это делается разрешением всех
типов по цепочке. В случае, если тип ссылается на несуществующий тип
или цепочка определений замыкается в кольцо, загрузка схемы завершается
с ошибкой.

#### Встроенные типы.
Схема поддерживает следующие встроенные типы:

- `byte`
- `char — `UTF8_CHAR` в Java коде.
- `short`
- `int`
- `compact_int`
- `byte_array`
- `utf_char_array`
- `tiny_decimal` — `DECIMAL` в Java коде. `decimal` должен быть переопределён как
  `tiny_decimal` или `wide_decimal` в схеме. 
- `short_string`
- `time_seconds`
- `time_millis`
- `time_nanos`
- `time`
- `sequence`
- `date`
- `long`
- `wide_decimal`
- `string`
- `custom_object`
- `serial_object`

Кроме того, дополнительно поддерживаются типы, которые в будущем будет использоваться
при генерировании связей между записями и объектами событий. 

- `time_nano_part` 
- `index`
- `flags`

Сейчас эти три дополнительных типа являются псевдонимами `compact_int`.

### Перечисления.
> На данный момент перечисления никак не используются
> в Java-реализации QD, так как Java-реализация QD ещё не имеет кодогенератора
> событий и связей между событиями и записями, основанного на машино-читаемой
> схеме.

Элемент `<enum>` создаёт новый тип-перечисление. Перечисление состоит из
списка возможных значений, каждое с уникальным именем и своим числовым значением.
Числовые значения могут быть опущены, тогда элементы нумеруются с шагом 1 начиная
с последнего заданного значения или нуля если значения вообще не заданы.

Элементы `<enum>` помещаются в контейнер `<enums>`.

Перечисление является именованным объектом и может содержать документацию.

Перечисление может содержать значения, определяемые элементами `<value>`.

Каждое значение является в свою очередь именованным объектом и может содержать
документацию.

Помимо обязательного для именованных объектов атрибута `name` и опционального
`mode`, элемент `<value>` может содержать опциональный атрибут `ord`. Значением
этого атрибута должно быть неотрицательное целое число, записанное в десятичной системе
счисления. Этот атрибут задаёт числовое значение соответствующее данному элементу
перечисления. Если атрибут не задан, то новые добавленные значения нумеруются по
порядку от предыдущего добавленного значения с заданным атрибутом `ord`
или с нуля если атрибут `ord` не задан ни для одного значения.

При добавлении новых значений в уже существующее перечисление значения без атрибута
`ord` нумеруются как если бы они были изначально созданы в исходном перечислении.

### Записи.
Элемент `<record>` описывает одну или несколько (в случае регионалов)
записей, используемых на транспортном уровне QD.

Элементы `<record>` помещаются в контейнер `<records>`.

Запись является именованным объектом и может содержать документацию.

Все записи, включённые прямо в контейнер `<records>`, образуют единое пространство
имён.

Запись содержит набор полей и опциональную конфигурации времени (индекса) для контракта
history.

Помимо обязательного для именованных объектов атрибута `name` и опционального
`mode`, элемент `<record>` поддерживает следующие атрибуты:

- `copyFrom` — опциональный атрибут, определяющий имя записи-образца, см. ниже.

- `disabled` — опциональный атрибут логического типа (`false` по умолчанию).

  Если этот атрибут имеет значение `true` то данная запись не будет
  сконфигурирована в ядре QD, но может использоваться как образец.

  Так же на активность записи влияют правила видимости (см. ниже),
  так что переопределять запись только для смены значения данного атрибута
  необязательно.

- `regionals` — опциональный атрибут логического типа (`false` по умолчанию).

  Если атрибут установлен в `true`, то запись служит шаблоном для самой себя и
  дополнительных 26 записей с суффиксами от `&A до `&Z`.

  Список регионалов не регулируется, но ненужные записи могут быть отключены
  правилами видимости.

- ~`eventName`~ — опциональный псевдоним записи для использования совместно
  со специальными правилами видимости.

  Если этот атрибут не задан, то он совпадает с именем самой записи.

  > Данный атрибут существует только для обеспечения обратной
  > совместимости и не должен использоваться не-Java реализациями QD.


##### Создание записей по образцу.
Новая запись может быть построена на основе другой, уже описанной, записи
(называемой дальше «образцом»).

При этом разрешение такой ссылки происходит прямо во время чтения каждого файла и образец
должен существовать в тот момент, когда на него ссылаются. Если запись-образец
будет обновлена дальнейшими файлами, это никак не повлияет на уже созданные по этому
образцу записи. При создании записей по образцу атрибут образца `disabled` не наследуется,
так что образец может быть выключен (`disabled="true"`), но все записи,
созданные на его основе, будут разрешены по умолчанию.

Невозможно создать по образцу обновление записи, так что значение `update` атрибута `mode`
не совместимо с наличием атрибута `copyFrom`.

##### Поля, составляющие время (индекс) записи.
Записи, передаваемые с контрактом history, должны содержать 1 или 2 поля помеченные для
использования в качестве времени (индекса).

Эти поля задаются с помощью элемента `<index>`, который может быть включён в запись 1 раз
или не включён вовсе. У этого элемента есть 2 атрибута `field0` и `field1`. Хотя бы
один из этих атрибутов должен присутствовать. Значениями этих атрибутов служат имена полей,
присутствующих в записи.

Этот элемент может идти до определения всех полей записи, так как его проверка происходит
после загрузки схемы.

Если один из атрибутов элемента `<index>` ссылается на отсутствующее поле, то загрузка
схемы завершится с ошибкой.

Если одно из полей индекса отсутствует (не задано), то при конфигурации ядра QD будет
сформировано поле-заглушка с типом `void`.

#### Поля записи.
Новая запись должна включать одно или больше полей. Записи с режимом `update` может
не содержать полей вовсе и быть задана для изменения атрибутов или индекса контракта
history.

Каждое поле задаётся элементом `<field>`. Поле является именованным объектом
и может содержать документацию.

Каждое поле имеет тип. Окончательный (встроенный) тип поля определяется
после чтения и объединения всех файлов схемы, так что более позднее определение
типа влияет на поля записей, описанные до данного определения типа. Это позволяет
настраивать некоторые типы добавляя небольшой файл настройки типов после стандартной
схемы, не затрагивая файлы стандартной схемы. Также это позволяет
при определении поля ссылаться на ещё не определённый тип.

Если после загрузки и объединения всех файлов схемы какие-то поля будут ссылаться
на неизвестные типы, загрузка схемы прервётся с ошибкой.

Помимо обязательного для именованных объектов атрибута `name` и опционального
`mode`, элемент `<field>` поддерживает следующие атрибуты:

- `type` — обязательный атрибут, задающий тип поля.

  Этот атрибут должен содержать имя встроенного типа или типа определённого
  с помощью конструкции `<type>`.

  Атрибут обязателен только для полей с атрибутом `mode` равным `new`.
  Переопределение поля в последующих файлах может не содержать этот атрибут,
  тогда тип поля не меняется, но могут быть изменены другие его атрибуты и
  свойства.

- `disabled` — опциональный атрибут логического типа (`false` по умолчанию).

  Если этот атрибут имеет значение `true` то данное поле записи не будет
  сконфигурировано в ядре QD.

  Так же на активность поля записи влияют правила видимости (см. ниже),
  так что переопределять запись и поле только для смены значения данного
  атрибута необязательно.

- `compositeOnly` — опциональный атрибут логического типа (`false`
  по умолчанию).
  
  Если этот атрибут имеет значение `true` то данное поле будет
  сконфигурировано в ядре QD только для записи не имеющей регионального
  суффикса (см. атрибут `regionals` у записи).

  Для полей, включённых в запись без атрибута `regionals` это поле
  допускается, но не оказывает никакого влияния.

- ~`eventName`~ — опциональный псевдоним записи для использования совместно
  со специальными правилами видимости.

  Если этот атрибут не задан, то он совпадает с `eventName` самой записи.

  Данный атрибут позволяет полю виртуально принадлежать событию с именем
  отличным от имени записи.

  > Данный атрибут существует только для обеспечения обратной
  > совместимости и не должен использоваться не-Java реализациями QD.

Каждое поле может помимо перечисленных атрибутов обладать несколькими
псевдонимами и несколькими тегами.

Так же поля типа `flags` могут иметь описание битовых под-полей
внутри себя.

#### Псевдонимы полей.
Поле, помимо основного имени, может иметь несколько псевдонимов. Один
из псевдонимов считается главным.

> На данный момент используется только главный псевдоним, остальные
> загружаются из файлов схемы, но не используются.

Псевдонимы поля перечисляются в элементах `<alias>`, вложенных
в элемент `<field>`. Каждый элемент `<alias>` может иметь три атрибута:

- `name` — обязательный атрибут, определяющий псевдоним.

- `main` — опциональный атрибут логического типа.

  Определяет, является ли данный псевдоним главным.

  У поля может быть только одни псевдоним, помеченный как главный.
  В случае, если несколько псевдонимов имеют этот атрибут установленным
  в `true`, загрузка схемы завершается с ошибкой.

- `mode` — опциональный атрибут, принимающий значения `add` (по умолчанию)
  или `remove`.

  Этот атрибут позволяет удалить псевдоним у уже определённого поля при
  обновлении записи в последующих файлах.

  Добавление уже существующего псевдонима или удаление несуществующего приводит
  к ошибке загрузки схемы.

Если ни один из псевдонимов не помечен как главный, главным выбирается
псевдоним определённый первым.

Если у поля есть главный псевдоним (т.е. определён хотя бы один псевдоним),
то именно он используется как имя поля записи в ядре QD. В таком
случае имя поля используется в качестве имени свойства (property name) QD-записи.

#### Теги полей.
Поле может быть помечено одним или несколькими тегами.

Теги используются в правилах видимости полей и позволяют упростить эти
правила, группируя родственные поля и разрешая или запрещая их
одним правилом.

Теги поля перечисляются в элементах `<tag>`, вложенных
в элемент `<field>`. Каждый элемент `<tag>` имеет два атрибута:

- `name` — обязательный атрибут, определяющий тег.

- `mode` — опциональный атрибут, принимающий значения `add` (по умолчанию)
  или `remove`.

  Этот атрибут позволяет удалить тег у уже определённого поля при
  обновлении записи в последующих файлах.

  Добавление уже существующего тега или удаление не существующего приводит
  к ошибке загрузки схемы.

#### Битовые поля флагов.
Поля типа `flags` могут иметь описание битовых под-полей внутри себя.

> На данный момент битовые поля внутри флагов никак не используются
> в Java-реализации QD, так как Java-реализация QD ещё не имеет кодогенератора
> событий и связей между событиями и записями, основанного на машино-читаемой
> схеме.

Битовые поля определяются помещением элемента-контейнера `<bitfields>` в элемент
`<field>`. Если поле имеет тип отличный от `flags`, то появление элемента
`<bitfields>` является ошибкой и приводит к ошибке загрузки всей схемы.

Тип поля `flags` должен быть задан непосредственно, а не через промежуточный
псевдоним типа `<type>`.

Контейнер `<bitfields>` содержит одно или больше определение битового поля.

Каждое битовое поле определяется элементом `<field>` (отличным от родительского
элемента `<field>`).

Битовое поле является именованным объектом и может содержать документацию.

Помимо обязательного для именованных объектов атрибута `name` и опционального
`mode`, битовое поле поддерживает следующие атрибуты:

- `offset` — обязательный атрибут числового типа в диапазоне от 0 до 63 (включительно).

  Этот атрибут определяет смещение битового поля внутри 64-х битного поля типа `flags.

- `size` — обязательный атрибут числового типа в диапазоне от 1 до 64 (включительно).

  Этот атрибут определяет размер битового поля внутри 64-х битного поля типа `flags.

- `disabled` — опциональный атрибут логического типа (`false` по умолчанию).

Все битовые поля одного поля типа `flags` не должны пересекаться. В случае нарушения
этого правила загрузка схемы завершается с ошибкой.

### Генераторы семейства записей.
Группы одинаковых записей, отличающихся только именами, могут быть сгенерированы
с помощью генераторов записей.

Элемент `<generator>` описывает один генератор, создающий несколько
одинаковых по структуре записей, используемых на транспортном уровне QD.

Элементы `<generator>` помещаются в контейнер `<records>`.

Генератор является именованным объектом и может содержать документацию.

Генераторы образуют отдельное от записей и единое для всех генераторов
пространство имён.

Каждый генератор состоит из итератора, определяющего список строк
которыми будут отличаться имена сгенерированных записей и одной или
нескольких записей, служащих шаблонами для генерации.

Генератор для каждой записи-шаблона конфигурирует в ядре QD столько записей,
сколько строк в его итераторе, трансформируя только имя записи и полностью
сохраняя структуру. Если образец имеет регионалы, то генерируются и
региональные варианты записи.

Все записи-шаблоны в рамках одного «родительского» генератора
образуют отдельное пространство имён, не пересекающееся ни с пространством
имён простых записей ни с пространствами имён образцов других генераторов.

На данный момент существует всего два вида трансформации имён шаблонов
при генерации: добавление строки из итератора в начало (prefix) или конец
(suffix) имени.

Так же для генератора может быть задана строка-разделитель, которая будет
добавляться между именем шаблона и строкой из итератора только в том случае, если
строка из итератора не пуста.

Помимо обязательного для именованных объектов атрибута `name` и опционального
`mode`, элемент `<generator>` поддерживает следующие атрибуты:

- `type` — опциональный атрибут режима трансформации имён записей.
  Может принимать значения `prefix` и `suffix`. Значение по умолчанию —
  `suffix`.

- `delimiter` — опциональный атрибут, задающий строку-разделитель
  имени образца и строки-итератора. Значение по умолчанию — пустая
  строка.

#### Итератор.
Итератор определяется элементом `<iterator>`, который должен идти
до всех записей-шаблонов.

Итератор имеет один необязательный атрибут:

- `mode` — опциональный атрибут, определяющий как должен обрабатываться
  данный итератор при объединении файлов. Возможные значения:
  - `new` — значение по умолчанию. Аналогично значению `new` атрибута
    `mode` у именованных объектов.
  - `append` — содержимое данного итератора должно быть добавлено к 
    уже существующему содержимому итератора при слиянии файлов.
  - `replace` — содержимое данного итератора должно заместить 
    уже существующее содержимое итератора при слиянии файлов.

Итератор со значениями `append` и `replace` у атрибута `mode`
может быть размещён только в генераторе, у которого атрибут `mode`
имеет значение `update`, иначе загрузка схемы завершится с ошибкой.

Внутри итератора помещаются строки, образующие множество (set).

Каждая строка задаётся содержимым элемента `<value>` не имеющего
атрибутов. Строка может быть пустой. 

Итератор может содержать произвольное число элементов `<value>`.

#### Записи-шаблоны.
Записи-шаблоны описываются элементом `<record>`, который эквивалентен
описанию отдельной записи.

Единственное отличие состоит в том, что эти записи помещаются в отдельное
пространство имён и могут пересекаться именем (до его трансформации с
помощью строк из итератора) с уже существующими именами записей.

Также есть особенность в обработке атрибута `copyFrom`: поиск записи-образца
производится в пространстве имён простых записей, не шаблонов генератора.

### Правила видимости.
Элементы `<enable>` и `<disable>` определяют инструкции разрешения и 
запрещения конфигурирования отдельных записей и их отдельных
полей в ядре QD. Они позволяют тонко настраивать схему данных,
основанную на стандартной схеме, путём отключения ненужных в данном случае
полей или наоборот разрешении опциональных полей, которые обычно не включены.

Эти инструкции обрабатываются при конфигурировании ядра QD
в порядке их загрузки из файлов схем. Поэтому порядок их размещения
в файлах схем очень важен.

Для каждой записи и каждого поля проверяются все инструкции от первой
до последней и «побеждает» последняя сработавшая инструкция.

Если же ни одна инструкция не подходит данной записи или данному полю,
то используется значение атрибута `disabled` этого объекта.

Инструкция разрешения записывается ка элемент `<enable>` а инструкция
запрещения как элемент `<disable>`.

Элементы `<enable>` и `<disable>` помещаются в контейнер `<visibility>`.

Эти два элемента имеют идентичную структуру и поддерживают следующие атрибуты:

- `record` — обязательный атрибут, имеющий формат регулярного
  выражения Java.

  Этот атрибут определяет к каким записям или полям каких
  записей будет применено данное правило.

  Регулярное выражение сравнивается с полным именем записи,
  так что `^` в начале и `$` в конце подразумеваются.

- `field` — опциональный атрибут, имеющий формат регулярного выражения.

  Если этот атрибут задан, то правило применяется к отдельным полям
  записей. Если атрибут не задан, то правило применяется к записям в целом.
  
- ~`useEventName`~ — опциональный атрибут логического типа. Значение по умолчанию
  `false`.

  Определяет, будет выражение, описанное в атрибуте `record` сравнивается
  с именем записи или с её атрибутом `eventName`.

  > Данный атрибут существует только для обеспечения обратной
  > совместимости и не должен использоваться не-Java реализациями QD.

Также правило видимости может искать совпадения с полями записей не только
по имени, но и по наличию или отсутствию определённых тегов, что позволяет
писать более гибкие правила, не перечисляющие множество имён полей.

Эти фильтры задаются двумя элементами: `<include-tags>` и `<exclude-tags>`.
Каждый из этих элементов может содержать любое количество элементов
`<tag>` которые и задают соответствующие условия совпадения.

#### Алгоритм работы правила видимости.
##### Правило видимости одной записи.
1. Если у правила есть атрибут `field` или один из фильтров `include-tags` или
   `exclude-tags`, то правило не подходит к данной записи и **не влияет** на её
   видимость. Дальнейшие условия не проверяются.
1. 
   1. Если у правила атрибут `useEventName` имеет значение `false`, то за 
      *фактическое имя записи* принимается имя записи со всеми
      преобразованиями, заданными генератором и/или региональностью записи.
   1. Если у правила `useEventName` имеет значение `true`, то за
      *фактическое имя записи* принимается значение атрибута `eventName`
      записи.
1. Если *фактическое имя записи* не соответствует регулярному выражению,
   заданному атрибутом `record`, то правило не подходит к данной записи
   и **не влияет** на её видимость.
1. Во всех остальных случаях правило **влияет** на видимость данной записи.

##### Правило видимости одного поля записи.
1. Если у правила нет атрибута `field` и отсутствуют оба фильтра `include-tags` и
   `exclude-tags`, то правило не подходит к данному полю и **не влияет** на его
   видимость. Дальнейшие условия не проверяются.
1.
    1. Если у правила атрибут `useEventName` имеет значение `false`, то за
       *фактическое имя родительской записи* принимается имя записи, содержащей
       данное поле, со всеми преобразованиями, заданными генератором
       и/или региональностью записи.
    1. Если у правила `useEventName` имеет значение `true`, то за
       *фактическое имя родительской записи* принимается значение атрибута
       `eventName` поля.
1. Если *фактическое имя родительской записи* не соответствует регулярному
   выражению, заданному атрибутом `record`, то правило не подходит к данному
   полю и **не влияет** на его видимость. Дальнейшие условия не проверяются.
1. Если имя поля не соответствует регулярному выражению, заданному атрибутом
   `field`, то правило не подходит к данному полю и **не влияет** на его
   видимость. Дальнейшие условия не проверяются.
1. Поле должно иметь *все* теги, входящие во множество
   `include-tags`. Если это не так, то правило не подходит к данному полю
   и **не влияет** на его видимость. Дальнейшие условия не проверяются. 
1. Поле должно не иметь *ни одного* тега из входящих во множество
   `exclude-tags`. Если это не так, то правило не подходит к данному полю
   и **не влияет** на его видимость. Дальнейшие условия не проверяются.
1. Во всех остальных случаях правило **влияет** на видимость данного поля.

Обратите внимание, что если множество `include-tags` или `exclude-tags` 
пустые, то соответствующие условия выполняются автоматически для любого
набора тегов, которыми помечено поле.